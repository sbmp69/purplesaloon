{"ast":null,"code":"var _jsxFileName = \"E:\\\\purplesaloon\\\\client\\\\src\\\\context\\\\TokenContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useCallback, useEffect } from 'react';\nimport { supabase } from '../utils/supabase';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const TokenContext = /*#__PURE__*/createContext();\nexport const TokenProvider = ({\n  children\n}) => {\n  _s();\n  const [loading, setLoading] = useState(true);\n  const [currentMaleToken, setCurrentMaleToken] = useState(null);\n  const [currentFemaleToken, setCurrentFemaleToken] = useState(null);\n  const [tokens, setTokens] = useState({\n    male: [],\n    female: []\n  });\n\n  // Add headers for JSON content type\n  useEffect(() => {\n    supabase.realtime.setAuth(process.env.REACT_APP_SUPABASE_ANON_KEY);\n  }, []);\n\n  // Fetch current token for a gender\n  const getCurrentToken = useCallback(async gender => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(table).select('*').order('created_at', {\n        ascending: false\n      }).limit(1).single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error(`Error getting current ${gender} token:`, error);\n      return null;\n    }\n  }, []);\n\n  // Add a new token with OTP verification\n  const addToken = async (name, phone, service, gender) => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    const otp = Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit OTP\n\n    try {\n      setLoading(true);\n\n      // Get the next token number\n      const {\n        data: lastToken,\n        error: tokenError\n      } = await supabase.from(table).select('token_number').order('token_number', {\n        ascending: false\n      }).limit(1);\n      if (tokenError) {\n        console.error('Error getting last token:', tokenError);\n        throw tokenError;\n      }\n      const nextTokenNumber = lastToken && lastToken[0] ? lastToken[0].token_number + 1 : 1;\n\n      // Insert new token with OTP (not verified yet)\n      const tokenData = {\n        name,\n        phone,\n        service,\n        token_number: nextTokenNumber,\n        status: 'waiting',\n        otp,\n        created_at: new Date().toISOString()\n      };\n      console.log('Inserting token:', {\n        table,\n        tokenData\n      });\n      const {\n        data,\n        error\n      } = await supabase.from(table).insert(tokenData).select();\n      if (error) {\n        console.error('Supabase insert error:', error);\n        throw error;\n      }\n      if (!data || data.length === 0) {\n        throw new Error('No data returned from insert');\n      }\n      return {\n        ...data[0],\n        otp\n      }; // Return token data with OTP\n    } catch (error) {\n      console.error('Error in addToken:', error);\n      throw new Error(error.message || 'Failed to add token');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Verify OTP and update token status\n  const verifyOTP = async (tokenId, userOTP, gender) => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    try {\n      // Check if OTP matches\n      const {\n        data: tokenData,\n        error: fetchError\n      } = await supabase.from(table).select('*').eq('id', tokenId);\n      if (fetchError) {\n        console.error('Error fetching token for OTP verification:', fetchError);\n        throw new Error('Failed to verify OTP');\n      }\n      const token = tokenData && tokenData[0];\n      if (!token) {\n        throw new Error('Token not found');\n      }\n      if (token.otp !== userOTP) {\n        throw new Error('Invalid OTP');\n      }\n\n      // Update token as verified\n      const {\n        data: updatedTokenData,\n        error: updateError\n      } = await supabase.from(table).update({\n        status: 'verified',\n        verified_at: new Date().toISOString()\n      }).eq('id', tokenId).select();\n      if (updateError) {\n        console.error('Error updating token status:', updateError);\n        throw new Error('Failed to verify token');\n      }\n      if (!updatedTokenData || updatedTokenData.length === 0) {\n        throw new Error('No data returned after verification');\n      }\n\n      // Update local state\n      const updatedToken = updatedTokenData[0];\n      if (gender === 'male') {\n        setCurrentMaleToken(updatedToken);\n      } else {\n        setCurrentFemaleToken(updatedToken);\n      }\n\n      // Update tokens list\n      setTokens(prev => ({\n        ...prev,\n        [gender]: prev[gender].map(t => t.id === updatedToken.id ? {\n          ...t,\n          status: 'verified'\n        } : t)\n      }));\n      return updatedToken;\n    } catch (error) {\n      console.error('Error in verifyOTP:', error);\n      throw new Error(error.message || 'Failed to verify OTP');\n    }\n  };\n\n  // Serve a token\n  const serveToken = async (tokenId, gender) => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(table).update({\n        status: 'served'\n      }).eq('id', tokenId).select().single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error serving token:', error);\n      throw error;\n    }\n  };\n\n  // Get recent token\n  const getRecentToken = useCallback(async gender => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from(table).select('*').order('created_at', {\n        ascending: false\n      }).limit(1).single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error(`Error getting recent ${gender} token:`, error);\n      return null;\n    }\n  }, []);\n\n  // Fetch all tokens for a gender\n  const fetchTokens = useCallback(async gender => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    try {\n      setLoading(true);\n      const {\n        data,\n        error\n      } = await supabase.from(table).select('*').order('created_at', {\n        ascending: false\n      });\n      if (error) {\n        console.error(`Error fetching ${gender} tokens:`, error);\n        throw error;\n      }\n\n      // Ensure we have an array\n      const tokensList = Array.isArray(data) ? data : [];\n      setTokens(prev => ({\n        ...prev,\n        [gender]: tokensList\n      }));\n\n      // Update current token if available\n      if (tokensList.length > 0) {\n        const currentToken = tokensList.find(t => t.status === 'served') || tokensList[0];\n        if (gender === 'male') {\n          setCurrentMaleToken(currentToken);\n        } else {\n          setCurrentFemaleToken(currentToken);\n        }\n      }\n      return tokensList;\n    } catch (error) {\n      console.error(`Error in fetchTokens for ${gender}:`, error);\n      // Return empty array instead of throwing to prevent UI crashes\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Set up real-time subscriptions\n  useEffect(() => {\n    // Initial data fetch\n    const loadInitialData = async () => {\n      setLoading(true);\n      try {\n        const [maleToken, femaleToken, maleTokens, femaleTokens] = await Promise.all([getCurrentToken('male'), getCurrentToken('female'), fetchTokens('male'), fetchTokens('female')]);\n        setCurrentMaleToken(maleToken);\n        setCurrentFemaleToken(femaleToken);\n        setTokens({\n          male: maleTokens,\n          female: femaleTokens\n        });\n      } catch (error) {\n        console.error('Error loading initial data:', error);\n      } finally {\n        setLoading(false);\n      }\n    };\n    loadInitialData();\n\n    // Subscribe to real-time updates\n    const menSubscription = supabase.channel('men_queue_changes').on('postgres_changes', {\n      event: '*',\n      schema: 'public',\n      table: 'men_queue'\n    }, async () => {\n      const [token, tokenList] = await Promise.all([getCurrentToken('male'), fetchTokens('male')]);\n      setCurrentMaleToken(token);\n      setTokens(prev => ({\n        ...prev,\n        male: tokenList\n      }));\n    }).subscribe();\n    const womenSubscription = supabase.channel('women_queue_changes').on('postgres_changes', {\n      event: '*',\n      schema: 'public',\n      table: 'women_queue'\n    }, async () => {\n      const [token, tokenList] = await Promise.all([getCurrentToken('female'), fetchTokens('female')]);\n      setCurrentFemaleToken(token);\n      setTokens(prev => ({\n        ...prev,\n        female: tokenList\n      }));\n    }).subscribe();\n    return () => {\n      supabase.removeChannel(menSubscription);\n      supabase.removeChannel(womenSubscription);\n    };\n  }, [fetchTokens, getCurrentToken]);\n  return /*#__PURE__*/_jsxDEV(TokenContext.Provider, {\n    value: {\n      tokens,\n      loading,\n      currentMaleToken,\n      currentFemaleToken,\n      addToken,\n      verifyOTP,\n      serveToken,\n      getRecentToken,\n      fetchTokens,\n      getCurrentToken: gender => gender === 'male' ? currentMaleToken : currentFemaleToken\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 319,\n    columnNumber: 5\n  }, this);\n};\n_s(TokenProvider, \"ANDg4i9G8JkTgdV6yykBn7eDIfw=\");\n_c = TokenProvider;\nexport default TokenProvider;\nvar _c;\n$RefreshReg$(_c, \"TokenProvider\");","map":{"version":3,"names":["React","createContext","useState","useCallback","useEffect","supabase","jsxDEV","_jsxDEV","TokenContext","TokenProvider","children","_s","loading","setLoading","currentMaleToken","setCurrentMaleToken","currentFemaleToken","setCurrentFemaleToken","tokens","setTokens","male","female","realtime","setAuth","process","env","REACT_APP_SUPABASE_ANON_KEY","getCurrentToken","gender","table","data","error","from","select","order","ascending","limit","single","console","addToken","name","phone","service","otp","Math","floor","random","toString","lastToken","tokenError","nextTokenNumber","token_number","tokenData","status","created_at","Date","toISOString","log","insert","length","Error","message","verifyOTP","tokenId","userOTP","fetchError","eq","token","updatedTokenData","updateError","update","verified_at","updatedToken","prev","map","t","id","serveToken","getRecentToken","fetchTokens","tokensList","Array","isArray","currentToken","find","loadInitialData","maleToken","femaleToken","maleTokens","femaleTokens","Promise","all","menSubscription","channel","on","event","schema","tokenList","subscribe","womenSubscription","removeChannel","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["E:/purplesaloon/client/src/context/TokenContext.js"],"sourcesContent":["import React, { createContext, useState, useCallback, useEffect } from 'react';\nimport { supabase } from '../utils/supabase';\n\nexport const TokenContext = createContext();\n\nexport const TokenProvider = ({ children }) => {\n  const [loading, setLoading] = useState(true);\n  const [currentMaleToken, setCurrentMaleToken] = useState(null);\n  const [currentFemaleToken, setCurrentFemaleToken] = useState(null);\n  const [tokens, setTokens] = useState({ male: [], female: [] });\n\n  // Add headers for JSON content type\n  useEffect(() => {\n    supabase.realtime.setAuth(process.env.REACT_APP_SUPABASE_ANON_KEY);\n  }, []);\n\n  // Fetch current token for a gender\n  const getCurrentToken = useCallback(async (gender) => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    try {\n      const { data, error } = await supabase\n        .from(table)\n        .select('*')\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error(`Error getting current ${gender} token:`, error);\n      return null;\n    }\n  }, []);\n\n  // Add a new token with OTP verification\n  const addToken = async (name, phone, service, gender) => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    const otp = Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit OTP\n    \n    try {\n      setLoading(true);\n      \n      // Get the next token number\n      const { data: lastToken, error: tokenError } = await supabase\n        .from(table)\n        .select('token_number')\n        .order('token_number', { ascending: false })\n        .limit(1);\n        \n      if (tokenError) {\n        console.error('Error getting last token:', tokenError);\n        throw tokenError;\n      }\n      \n      const nextTokenNumber = lastToken && lastToken[0] ? lastToken[0].token_number + 1 : 1;\n      \n      // Insert new token with OTP (not verified yet)\n      const tokenData = { \n        name, \n        phone, \n        service, \n        token_number: nextTokenNumber,\n        status: 'waiting',\n        otp,\n        created_at: new Date().toISOString()\n      };\n\n      console.log('Inserting token:', { table, tokenData });\n      \n      const { data, error } = await supabase\n        .from(table)\n        .insert(tokenData)\n        .select();\n\n      if (error) {\n        console.error('Supabase insert error:', error);\n        throw error;\n      }\n\n      if (!data || data.length === 0) {\n        throw new Error('No data returned from insert');\n      }\n\n      return { ...data[0], otp }; // Return token data with OTP\n\n    } catch (error) {\n      console.error('Error in addToken:', error);\n      throw new Error(error.message || 'Failed to add token');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Verify OTP and update token status\n  const verifyOTP = async (tokenId, userOTP, gender) => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    \n    try {\n      // Check if OTP matches\n      const { data: tokenData, error: fetchError } = await supabase\n        .from(table)\n        .select('*')\n        .eq('id', tokenId);\n\n      if (fetchError) {\n        console.error('Error fetching token for OTP verification:', fetchError);\n        throw new Error('Failed to verify OTP');\n      }\n\n      const token = tokenData && tokenData[0];\n      if (!token) {\n        throw new Error('Token not found');\n      }\n\n      if (token.otp !== userOTP) {\n        throw new Error('Invalid OTP');\n      }\n\n      // Update token as verified\n      const { data: updatedTokenData, error: updateError } = await supabase\n        .from(table)\n        .update({ \n          status: 'verified',\n          verified_at: new Date().toISOString()\n        })\n        .eq('id', tokenId)\n        .select();\n\n      if (updateError) {\n        console.error('Error updating token status:', updateError);\n        throw new Error('Failed to verify token');\n      }\n\n      if (!updatedTokenData || updatedTokenData.length === 0) {\n        throw new Error('No data returned after verification');\n      }\n\n      // Update local state\n      const updatedToken = updatedTokenData[0];\n      if (gender === 'male') {\n        setCurrentMaleToken(updatedToken);\n      } else {\n        setCurrentFemaleToken(updatedToken);\n      }\n\n      // Update tokens list\n      setTokens(prev => ({\n        ...prev,\n        [gender]: prev[gender].map(t => \n          t.id === updatedToken.id ? { ...t, status: 'verified' } : t\n        )\n      }));\n\n      return updatedToken;\n\n    } catch (error) {\n      console.error('Error in verifyOTP:', error);\n      throw new Error(error.message || 'Failed to verify OTP');\n    }\n  };\n\n  // Serve a token\n  const serveToken = async (tokenId, gender) => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    try {\n      const { data, error } = await supabase\n        .from(table)\n        .update({ status: 'served' })\n        .eq('id', tokenId)\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error serving token:', error);\n      throw error;\n    }\n  };\n\n  // Get recent token\n  const getRecentToken = useCallback(async (gender) => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    try {\n      const { data, error } = await supabase\n        .from(table)\n        .select('*')\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error(`Error getting recent ${gender} token:`, error);\n      return null;\n    }\n  }, []);\n\n  // Fetch all tokens for a gender\n  const fetchTokens = useCallback(async (gender) => {\n    const table = gender === 'male' ? 'men_queue' : 'women_queue';\n    try {\n      setLoading(true);\n      \n      const { data, error } = await supabase\n        .from(table)\n        .select('*')\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        console.error(`Error fetching ${gender} tokens:`, error);\n        throw error;\n      }\n      \n      // Ensure we have an array\n      const tokensList = Array.isArray(data) ? data : [];\n      \n      setTokens(prev => ({\n        ...prev,\n        [gender]: tokensList\n      }));\n      \n      // Update current token if available\n      if (tokensList.length > 0) {\n        const currentToken = tokensList.find(t => t.status === 'served') || tokensList[0];\n        if (gender === 'male') {\n          setCurrentMaleToken(currentToken);\n        } else {\n          setCurrentFemaleToken(currentToken);\n        }\n      }\n      \n      return tokensList;\n    } catch (error) {\n      console.error(`Error in fetchTokens for ${gender}:`, error);\n      // Return empty array instead of throwing to prevent UI crashes\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Set up real-time subscriptions\n  useEffect(() => {\n    // Initial data fetch\n    const loadInitialData = async () => {\n      setLoading(true);\n      try {\n        const [maleToken, femaleToken, maleTokens, femaleTokens] = await Promise.all([\n          getCurrentToken('male'),\n          getCurrentToken('female'),\n          fetchTokens('male'),\n          fetchTokens('female')\n        ]);\n\n        setCurrentMaleToken(maleToken);\n        setCurrentFemaleToken(femaleToken);\n        setTokens({\n          male: maleTokens,\n          female: femaleTokens\n        });\n      } catch (error) {\n        console.error('Error loading initial data:', error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadInitialData();\n\n    // Subscribe to real-time updates\n    const menSubscription = supabase\n      .channel('men_queue_changes')\n      .on('postgres_changes', \n        { \n          event: '*', \n          schema: 'public', \n          table: 'men_queue' \n        }, \n        async () => {\n          const [token, tokenList] = await Promise.all([\n            getCurrentToken('male'),\n            fetchTokens('male')\n          ]);\n          setCurrentMaleToken(token);\n          setTokens(prev => ({ ...prev, male: tokenList }));\n        }\n      )\n      .subscribe();\n\n    const womenSubscription = supabase\n      .channel('women_queue_changes')\n      .on('postgres_changes', \n        { \n          event: '*', \n          schema: 'public', \n          table: 'women_queue' \n        }, \n        async () => {\n          const [token, tokenList] = await Promise.all([\n            getCurrentToken('female'),\n            fetchTokens('female')\n          ]);\n          setCurrentFemaleToken(token);\n          setTokens(prev => ({ ...prev, female: tokenList }));\n        }\n      )\n      .subscribe();\n\n    return () => {\n      supabase.removeChannel(menSubscription);\n      supabase.removeChannel(womenSubscription);\n    };\n  }, [fetchTokens, getCurrentToken]);\n\n  return (\n    <TokenContext.Provider\n      value={{\n        tokens,\n        loading,\n        currentMaleToken,\n        currentFemaleToken,\n        addToken,\n        verifyOTP,\n        serveToken,\n        getRecentToken,\n        fetchTokens,\n        getCurrentToken: (gender) => \n          gender === 'male' ? currentMaleToken : currentFemaleToken,\n      }}\n    >\n      {children}\n    </TokenContext.Provider>\n  );\n};\n\nexport default TokenProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}